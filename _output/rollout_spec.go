// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package _output

import "encoding/json"
import "fmt"

// The action to be taken upon failure.
type OnFailure struct {
	// The properties to define continue upon failure.
	Continue *OnFailureContinue `json:"continue,omitempty" yaml:"continue,omitempty" mapstructure:"continue,omitempty"`

	// The properties to define retry upon failure.
	Retry *OnFailureRetry `json:"retry,omitempty" yaml:"retry,omitempty" mapstructure:"retry,omitempty"`
}

// The properties to define continue upon failure.
type OnFailureContinue struct {
	// Error conditions on which continue should be triggered.
	Conditions OnFailureContinueConditions `json:"conditions" yaml:"conditions" mapstructure:"conditions"`
}

// Error conditions on which continue should be triggered.
type OnFailureContinueConditions struct {
	// The list of error conditions on which rollout should be continued.
	ErrorsContainAny []string `json:"errorsContainAny" yaml:"errorsContainAny" mapstructure:"errorsContainAny"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OnFailureContinueConditions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["errorsContainAny"]; raw != nil && !ok {
		return fmt.Errorf("field errorsContainAny in OnFailureContinueConditions: required")
	}
	type Plain OnFailureContinueConditions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OnFailureContinueConditions(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OnFailureContinue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["conditions"]; raw != nil && !ok {
		return fmt.Errorf("field conditions in OnFailureContinue: required")
	}
	type Plain OnFailureContinue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OnFailureContinue(plain)
	return nil
}

// The properties to define retry upon failure.
type OnFailureRetry struct {
	// Error conditions on which retry should be triggered.
	Conditions OnFailureRetryConditions `json:"conditions" yaml:"conditions" mapstructure:"conditions"`

	// Max number of retries to be attempted.
	MaxRetryAttempts int `json:"maxRetryAttempts" yaml:"maxRetryAttempts" mapstructure:"maxRetryAttempts"`

	// The wait duration between each retry in ISO8601 format.
	WaitDurationBetweenRetry string `json:"waitDurationBetweenRetry" yaml:"waitDurationBetweenRetry" mapstructure:"waitDurationBetweenRetry"`
}

// Error conditions on which retry should be triggered.
type OnFailureRetryConditions struct {
	// The list of error conditions on which rollout should be retried.
	ErrorsContainAny []string `json:"errorsContainAny" yaml:"errorsContainAny" mapstructure:"errorsContainAny"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OnFailureRetryConditions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["errorsContainAny"]; raw != nil && !ok {
		return fmt.Errorf("field errorsContainAny in OnFailureRetryConditions: required")
	}
	type Plain OnFailureRetryConditions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OnFailureRetryConditions(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OnFailureRetry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["conditions"]; raw != nil && !ok {
		return fmt.Errorf("field conditions in OnFailureRetry: required")
	}
	if _, ok := raw["maxRetryAttempts"]; raw != nil && !ok {
		return fmt.Errorf("field maxRetryAttempts in OnFailureRetry: required")
	}
	if _, ok := raw["waitDurationBetweenRetry"]; raw != nil && !ok {
		return fmt.Errorf("field waitDurationBetweenRetry in OnFailureRetry: required")
	}
	type Plain OnFailureRetry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OnFailureRetry(plain)
	return nil
}

// A document that declares what actions are to be taken as part of an update to an
// Azure Service.
type RegionAgnosticRolloutSpecificationModifiedJson struct {
	// The version of the schema that a document conforms to.
	ContentVersion string `json:"contentVersion" yaml:"contentVersion" mapstructure:"contentVersion"`

	// The action to be taken upon failure.
	OnFailure *RegionAgnosticRolloutSpecificationModifiedJsonOnFailure `json:"onFailure,omitempty" yaml:"onFailure,omitempty" mapstructure:"onFailure,omitempty"`

	// The exact sequence of steps that must be executed as part of this rollout.
	OrchestratedSteps []RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem `json:"orchestratedSteps" yaml:"orchestratedSteps" mapstructure:"orchestratedSteps"`

	// The metadata associated with this particular rollout.
	RolloutMetadata RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata `json:"rolloutMetadata" yaml:"rolloutMetadata" mapstructure:"rolloutMetadata"`
}

// The action to be taken upon failure.
type RegionAgnosticRolloutSpecificationModifiedJsonOnFailure struct {
	// The properties to define continue upon failure.
	Continue *RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinue `json:"continue,omitempty" yaml:"continue,omitempty" mapstructure:"continue,omitempty"`

	// The properties to define retry upon failure.
	Retry *RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry `json:"retry,omitempty" yaml:"retry,omitempty" mapstructure:"retry,omitempty"`
}

// The properties to define continue upon failure.
type RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinue struct {
	// Error conditions on which continue should be triggered.
	Conditions RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinueConditions `json:"conditions" yaml:"conditions" mapstructure:"conditions"`
}

// Error conditions on which continue should be triggered.
type RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinueConditions struct {
	// The list of error conditions on which rollout should be continued.
	ErrorsContainAny []string `json:"errorsContainAny" yaml:"errorsContainAny" mapstructure:"errorsContainAny"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinueConditions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["errorsContainAny"]; raw != nil && !ok {
		return fmt.Errorf("field errorsContainAny in RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinueConditions: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinueConditions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinueConditions(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["conditions"]; raw != nil && !ok {
		return fmt.Errorf("field conditions in RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinue: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOnFailureContinue(plain)
	return nil
}

// The properties to define retry upon failure.
type RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry struct {
	// Error conditions on which retry should be triggered.
	Conditions RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetryConditions `json:"conditions" yaml:"conditions" mapstructure:"conditions"`

	// Max number of retries to be attempted.
	MaxRetryAttempts int `json:"maxRetryAttempts" yaml:"maxRetryAttempts" mapstructure:"maxRetryAttempts"`

	// The wait duration between each retry in ISO8601 format.
	WaitDurationBetweenRetry string `json:"waitDurationBetweenRetry" yaml:"waitDurationBetweenRetry" mapstructure:"waitDurationBetweenRetry"`
}

// Error conditions on which retry should be triggered.
type RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetryConditions struct {
	// The list of error conditions on which rollout should be retried.
	ErrorsContainAny []string `json:"errorsContainAny" yaml:"errorsContainAny" mapstructure:"errorsContainAny"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetryConditions) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["errorsContainAny"]; raw != nil && !ok {
		return fmt.Errorf("field errorsContainAny in RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetryConditions: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetryConditions
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetryConditions(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["conditions"]; raw != nil && !ok {
		return fmt.Errorf("field conditions in RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry: required")
	}
	if _, ok := raw["maxRetryAttempts"]; raw != nil && !ok {
		return fmt.Errorf("field maxRetryAttempts in RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry: required")
	}
	if _, ok := raw["waitDurationBetweenRetry"]; raw != nil && !ok {
		return fmt.Errorf("field waitDurationBetweenRetry in RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOnFailureRetry(plain)
	return nil
}

// An individual deployment step in the rollout of an Azure service.
type RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem struct {
	// The actions that must take place as part of this step. The actions will be
	// executed in the order that they are declared. The action names must be unique.
	// If this is an Extension action, the name of the extension must exist in the
	// 'Extensions' block in  RolloutParameters.
	Actions []interface{} `json:"actions" yaml:"actions" mapstructure:"actions"`

	// The details of applications to be deployed.
	Applications *RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications `json:"applications,omitempty" yaml:"applications,omitempty" mapstructure:"applications,omitempty"`

	// The names of the rollout steps that must be executed prior to the current step
	// being executed.
	DependsOn []string `json:"dependsOn,omitempty" yaml:"dependsOn,omitempty" mapstructure:"dependsOn,omitempty"`

	// The name of the rollout step.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// OnFailure corresponds to the JSON schema field "onFailure".
	OnFailure *OnFailure `json:"onFailure,omitempty" yaml:"onFailure,omitempty" mapstructure:"onFailure,omitempty"`

	// The property that marks the step as validation step.
	ServiceValidation *RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemServiceValidation `json:"serviceValidation,omitempty" yaml:"serviceValidation,omitempty" mapstructure:"serviceValidation,omitempty"`

	// The unique identifier of the target that is to be updated.
	TargetName string `json:"targetName" yaml:"targetName" mapstructure:"targetName"`

	// The type of the intended target of this rollout.
	TargetType string `json:"targetType" yaml:"targetType" mapstructure:"targetType"`
}

// The details of applications to be deployed.
type RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications struct {
	// The list of actions to be performed.
	Actions []string `json:"actions" yaml:"actions" mapstructure:"actions"`

	// The details of the service resources across which the application has to be
	// deployed.
	ApplyAcrossServiceResources RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplicationsApplyAcrossServiceResources `json:"applyAcrossServiceResources" yaml:"applyAcrossServiceResources" mapstructure:"applyAcrossServiceResources"`

	// The list of the application instance names..
	Names []string `json:"names" yaml:"names" mapstructure:"names"`
}

// The details of the service resources across which the application has to be
// deployed.
type RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplicationsApplyAcrossServiceResources struct {
	// The service resource definition name.
	DefinitionName string `json:"definitionName" yaml:"definitionName" mapstructure:"definitionName"`

	// Indicates if the cluster has to be deployed before application deployment.
	DeployArmResources *bool `json:"deployArmResources,omitempty" yaml:"deployArmResources,omitempty" mapstructure:"deployArmResources,omitempty"`

	// The list of service resource instance names.
	Names []string `json:"names,omitempty" yaml:"names,omitempty" mapstructure:"names,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplicationsApplyAcrossServiceResources) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["definitionName"]; raw != nil && !ok {
		return fmt.Errorf("field definitionName in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplicationsApplyAcrossServiceResources: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplicationsApplyAcrossServiceResources
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplicationsApplyAcrossServiceResources(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["actions"]; raw != nil && !ok {
		return fmt.Errorf("field actions in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications: required")
	}
	if _, ok := raw["applyAcrossServiceResources"]; raw != nil && !ok {
		return fmt.Errorf("field applyAcrossServiceResources in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications: required")
	}
	if _, ok := raw["names"]; raw != nil && !ok {
		return fmt.Errorf("field names in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemApplications(plain)
	return nil
}

// The property that marks the step as validation step.
type RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemServiceValidation struct {
	// The readiness state to unblock buildout of dependent services in an automated
	// fashion in new cloud/region buildout scenario.
	Readiness []string `json:"readiness" yaml:"readiness" mapstructure:"readiness"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemServiceValidation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["readiness"]; raw != nil && !ok {
		return fmt.Errorf("field readiness in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemServiceValidation: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemServiceValidation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElemServiceValidation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["actions"]; raw != nil && !ok {
		return fmt.Errorf("field actions in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem: required")
	}
	if _, ok := raw["targetName"]; raw != nil && !ok {
		return fmt.Errorf("field targetName in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem: required")
	}
	if _, ok := raw["targetType"]; raw != nil && !ok {
		return fmt.Errorf("field targetType in RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Actions != nil && len(plain.Actions) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "actions", 1)
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.TargetName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "targetName", 1)
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonOrchestratedStepsElem(plain)
	return nil
}

// The metadata associated with this particular rollout.
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata struct {
	// The location of the build to use for this particular rollout.
	BuildSource RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSource `json:"buildSource" yaml:"buildSource" mapstructure:"buildSource"`

	// Option to use configuration specification file directly in rollout.
	Configuration *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfiguration `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// The user-specified name of this particular rollout.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Notification definitions
	Notification *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotification `json:"notification,omitempty" yaml:"notification,omitempty" mapstructure:"notification,omitempty"`

	// List of rollout policy references to use for the rollout.
	RolloutPolicyReferences []RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem `json:"rolloutPolicyReferences,omitempty" yaml:"rolloutPolicyReferences,omitempty" mapstructure:"rolloutPolicyReferences,omitempty"`

	// The scope of this particular rollout.
	RolloutType *string `json:"rolloutType,omitempty" yaml:"rolloutType,omitempty" mapstructure:"rolloutType,omitempty"`

	// The path relative to the Service Group Root that points to the scope bindings
	// file.
	ScopeBindingsPath *string `json:"scopeBindingsPath,omitempty" yaml:"scopeBindingsPath,omitempty" mapstructure:"scopeBindingsPath,omitempty"`

	// The path relative to the Service Group Root that points to the generic service
	// model of the service that is being updated as part of this rollout.
	ServiceModelPath string `json:"serviceModelPath" yaml:"serviceModelPath" mapstructure:"serviceModelPath"`
}

// The location of the build to use for this particular rollout.
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSource struct {
	// The parameters that define how to access and/or prepare the build from this
	// build source.
	Parameters RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSourceParameters `json:"parameters" yaml:"parameters" mapstructure:"parameters"`
}

// The parameters that define how to access and/or prepare the build from this
// build source.
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSourceParameters struct {
	// The path relative to the Service Group Root which points to the file whose
	// contents represent the version of the build being deployed.
	VersionFile string `json:"versionFile" yaml:"versionFile" mapstructure:"versionFile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSourceParameters) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["versionFile"]; raw != nil && !ok {
		return fmt.Errorf("field versionFile in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSourceParameters: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSourceParameters
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSourceParameters(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["parameters"]; raw != nil && !ok {
		return fmt.Errorf("field parameters in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSource: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataBuildSource(plain)
	return nil
}

// Option to use configuration specification file directly in rollout.
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfiguration struct {
	// configuration spec reference list for ring scope
	RingScope []RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfigurationRingScopeElem `json:"ringScope,omitempty" yaml:"ringScope,omitempty" mapstructure:"ringScope,omitempty"`

	// Service Group scope configuration setting
	ServiceGroupScope *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfigurationServiceGroupScope `json:"serviceGroupScope,omitempty" yaml:"serviceGroupScope,omitempty" mapstructure:"serviceGroupScope,omitempty"`

	// Service scope configuration setting
	ServiceScope *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfigurationServiceScope `json:"serviceScope,omitempty" yaml:"serviceScope,omitempty" mapstructure:"serviceScope,omitempty"`
}

type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfigurationRingScopeElem struct {
	// The name of the target ring
	Ring *string `json:"ring,omitempty" yaml:"ring,omitempty" mapstructure:"ring,omitempty"`

	// The path, relative to the Service Group Root, that points to the ring scope
	// configuration specification for the current service group.
	ServiceGroupLevelSpecPath *string `json:"serviceGroupLevelSpecPath,omitempty" yaml:"serviceGroupLevelSpecPath,omitempty" mapstructure:"serviceGroupLevelSpecPath,omitempty"`

	// The path, relative to the Service Group Root, that points to the common ring
	// scope configuration specification across all service groups under the service.
	ServiceLevelSpecPath *string `json:"serviceLevelSpecPath,omitempty" yaml:"serviceLevelSpecPath,omitempty" mapstructure:"serviceLevelSpecPath,omitempty"`
}

// Service Group scope configuration setting
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfigurationServiceGroupScope struct {
	// The path, relative to the Service Group Root, that points to the service group
	// scope configuration specification.
	SpecPath *string `json:"specPath,omitempty" yaml:"specPath,omitempty" mapstructure:"specPath,omitempty"`
}

// Service scope configuration setting
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataConfigurationServiceScope struct {
	// The path relative to the Service Group Root that points to the service scope
	// configuration specification.
	SpecPath *string `json:"specPath,omitempty" yaml:"specPath,omitempty" mapstructure:"specPath,omitempty"`
}

// Notification definitions
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotification struct {
	// Email Notification definitions
	Email *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationEmail `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// Incident notification definitions
	Incident *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident `json:"incident,omitempty" yaml:"incident,omitempty" mapstructure:"incident,omitempty"`
}

// Email Notification definitions
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationEmail struct {
	// Cc email addresses list separator with ',;'
	Cc *string `json:"cc,omitempty" yaml:"cc,omitempty" mapstructure:"cc,omitempty"`

	// To email addresses list separator with ',;'
	To string `json:"to" yaml:"to" mapstructure:"to"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationEmail) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationEmail: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationEmail
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationEmail(plain)
	return nil
}

// Incident notification definitions
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident struct {
	// Conditions of when to create incidents, default will send on every error
	Options *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// The incident properties
	Properties RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties `json:"properties" yaml:"properties" mapstructure:"properties"`

	// The incident provider type
	ProviderType string `json:"providerType" yaml:"providerType" mapstructure:"providerType"`
}

// Conditions of when to create incidents, default will send on every error
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentOptions struct {
	// When corresponds to the JSON schema field "when".
	When []string `json:"when,omitempty" yaml:"when,omitempty" mapstructure:"when,omitempty"`
}

// The incident properties
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties struct {
	// The connector Id for ICM
	ConnectorId string `json:"connectorId" yaml:"connectorId" mapstructure:"connectorId"`

	// The incident correlation type.
	CorrelateBy *string `json:"correlateBy,omitempty" yaml:"correlateBy,omitempty" mapstructure:"correlateBy,omitempty"`

	// The environment of the incidents raising location.
	Environment *string `json:"environment,omitempty" yaml:"environment,omitempty" mapstructure:"environment,omitempty"`

	// The routing Id for ICM
	RoutingId string `json:"routingId" yaml:"routingId" mapstructure:"routingId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["connectorId"]; raw != nil && !ok {
		return fmt.Errorf("field connectorId in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties: required")
	}
	if _, ok := raw["routingId"]; raw != nil && !ok {
		return fmt.Errorf("field routingId in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncidentProperties(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident: required")
	}
	if _, ok := raw["providerType"]; raw != nil && !ok {
		return fmt.Errorf("field providerType in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataNotificationIncident(plain)
	return nil
}

// Policy reference details.
type RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem struct {
	// The name of the policy.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The version of the policy to use. Specify '*' to use the latest registered
	// version of the policy.
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadataRolloutPolicyReferencesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["buildSource"]; raw != nil && !ok {
		return fmt.Errorf("field buildSource in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata: required")
	}
	if _, ok := raw["serviceModelPath"]; raw != nil && !ok {
		return fmt.Errorf("field serviceModelPath in RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJsonRolloutMetadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RegionAgnosticRolloutSpecificationModifiedJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["contentVersion"]; raw != nil && !ok {
		return fmt.Errorf("field contentVersion in RegionAgnosticRolloutSpecificationModifiedJson: required")
	}
	if _, ok := raw["orchestratedSteps"]; raw != nil && !ok {
		return fmt.Errorf("field orchestratedSteps in RegionAgnosticRolloutSpecificationModifiedJson: required")
	}
	if _, ok := raw["rolloutMetadata"]; raw != nil && !ok {
		return fmt.Errorf("field rolloutMetadata in RegionAgnosticRolloutSpecificationModifiedJson: required")
	}
	type Plain RegionAgnosticRolloutSpecificationModifiedJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RegionAgnosticRolloutSpecificationModifiedJson(plain)
	return nil
}
